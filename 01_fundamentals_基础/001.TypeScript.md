# TypeScript

### 资料

1. [TypeScript 官方文档](https://www.typescriptlang.org/docs/handbook/intro.html)
2. [Effective TypeScript](https://rayadaschn.github.io/effective-typeScript-2nd-edition-zh/)
3. [Type Challenges](https://github.com/type-challenges/type-challenges/blob/main/README.zh-CN.md)

### 练习

#### 第一阶段：推断基础与控制流（第1-3天）

**阅读目标**：理解 TS 如何通过变量声明和逻辑分支“猜”类型。

**阅读内容**：

- Item 18：减少可推断类型的冗余。✅
- Item 22：理解类型收窄（Narrowing），这是 Vue 3 组合式 API 中处理 ref 值的核心逻辑。✅
- Item 25：了解 evolving any（演变的 any）的危险性。✅

**实战练习 (Type Challenges)**：

- [Warm-up] Hello World（熟悉环境） ✅
- [Easy] Pick / Omit / Readonly（手动实现基础工具类型，感受类型映射）
- [Easy] Exclude（初步接触裸类型参数的分发逻辑）

#### 第二阶段：高级推断与推断点（第4-7天）—— 重点攻克

**阅读目标**：掌握如何“引导” TS 做出更精确的推断，特别是在处理 API 和复杂泛型时。

**阅读内容**：

- Item 28：用类和柯里化创建新的类型推断点（你提供的链接内容）。
  - **关键点**：掌握 TS 的“全有或全无”推断原则，学会用高阶函数（柯里化）解决部分泛型手动指定、部分自动推断的需求。
- Item 24：理解上下文在推断中的作用。

**实战练习 (Type Challenges)**：

- [Medium] ReturnType：通过 infer 关键字手动实现获取函数返回值的逻辑。
- [Medium] Parameters：练习如何提取函数参数。
- [Medium] Chainable Options：实战演练 Item 28 中提到的“链式/柯里化”推断思想。

#### 第三阶段：泛型编程与递归（第8-11天）

**阅读目标**：进入“类型编程”领域，理解递归和模版字符串类型。

**阅读内容**：

- Item 50：将函数视为类型之间的转换。
- Item 54：模版字符串类型的 DSL 应用。
- Item 57：尾递归限制（了解 TS 处理深层嵌套类型的边界）。

**实战练习 (Type Challenges)**：

- [Medium] Deep Readonly：递归处理对象类型。
- [Medium] Replace / ReplaceAll：通过模版字符串类型操作字符串。
- [Medium] Last of Array：数组操作中的类型推断。

#### 第四阶段：工程实战与类型设计（第12-14天）

**阅读目标**：将类型技巧应用到 Vue 组件设计和业务逻辑中。

**阅读内容**：

- Item 29：设计产生有效状态的类型（避免 state: 'loading' | 'success' 这种不严谨的设计）。
- Item 34：偏好接口的并集而非并集的接口。

**实战练习 (Type Challenges)**：

- [Medium] Pop / Shift：数组结构变换。
- [Hard] Simple Vue：这是为你前端背景量身定制的题目，模拟 Vue 的 data/computed/methods 类型推断，是 Item 28 思想的终极应用。

💡 **针对前端工程师的实战建议**

Item 28 的实际应用场景：

作为 Vue 工程师，你经常会写 `useRequest<T>(url)`。当你发现 url 可以自动推断但 T 必须手动传时，就可以应用 Item 28 的柯里化技巧：

```typescript
// 原始：必须写两个参数，繁琐
const data = useRequest<User, '/api/user'>('/api/user'); 

// 柯里化优化：利用推断点分离
const request = defineApi<User>(); // 这里手动指定 T
const data = await request('/api/user'); // 这里 TS 会自动推断 Path 并校验
```