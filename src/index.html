<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      #io {
        margin: 8px;
      }
    </style>
  </head>
  <body>
    <div id="io">i am some inner html</div>
    <script src="https://cdn.bootcdn.net/ajax/libs/moment.js/2.27.0/moment.js"></script>
    <!-- <script src="https://cdn.bootcdn.net/ajax/libs/moment.js/2.27.0/locale/af.js"></script> -->
    <script>
      let margintop = getComputedStyle(io).marginTop
      console.log(margintop)
    </script>
    <script>
      function curry(fn) {
        const arity = fn.length;
        return function $curry(...args) {
          if (args.length < arity) {
            return $curry.bind(null, ...args);
          }

          return fn.call(null, ...args);
        };
      }
      const compose = (...fns) => (...args) =>
        fns.reduceRight((res, fn) => [fn.call(null, ...res)], args)[0];
      const map = curry((f, xs) => xs.map(f));
      const head = (xs) => xs[0];
      const last = (xs) => xs[xs.length - 1];
      const flip = curry((fn, a, b) => fn(b, a));
      const concat = curry((a, b) => a.concat(b));
      const split = curry((reg, s) => s.split(reg));
      const append = flip(concat);
      const find = curry((f, xs) => xs.filter(f));
      const prop = curry((p, obj) => obj[p]);
      const match = curry((reg, s) => s.match(reg));
      const add = curry((a, b) => a + b);
      const eq = curry((a, b) => a === b);
      const safeHead = safeProp(0);
      class Container {
        constructor(x) {
          this.$value = x;
        }
        static of(x) {
          return new Container(x);
        }
      }
      Container.prototype.map = function (f) {
        return Container.of(f(this.$value));
      };
      // let ret = Container.of(2).map((two) => two + 2);
      // let ret1 = Container.of('ff').map(s => s.toUpperCase())
      // let ret2 = Container.of('bombs').map(append(' away'))

      class Maybe {
        static of(x) {
          return new Maybe(x);
        }
        get isNothing() {
          return this.$value === null || this.$value === undefined;
        }
        constructor(x) {
          this.$value = x;
        }
        map(fn) {
          return this.isNothing ? this : Maybe.of(fn(this.$value));
        }
        inspect() {
          return this.isNothing ? "Nothing" : `Just(${inspect(this.$value)})`;
        }
      }
      let m3 = Maybe.of({ name: "hf" }).map(prop("age")).map(add(1));
      // const safeHead = (xs) => Maybe.of(xs[0]);
      const streetName = compose(
        map(prop("street")),
        safeHead,
        prop("addresses")
      );

      const withdraw = curry((amount, { balance }) =>
        Maybe.of(balance > amount ? { balance: balance - amount } : null)
      );

      const updateLedger = (account) => account;
      const remainingBalance = ({ balance }) => `Your balance is $${balance}`;
      const finishTransaction = compose(remainingBalance, updateLedger);
      //  const getTwenty = compose(map(finishTransaction), withdraw(20));
      const maybe = curry((v, f, m) => {
        if (m.isNothing) {
          return v;
        }
        return f(m.$value);
      });
      const getTwenty = compose(
        maybe("You're broke!", finishTransaction),
        withdraw(20)
      );

      //  let g1 = getTwenty({ balance: 200.00 });

      //  let s1 = streetName({ addresses: [] })
      //  let s2 = streetName({ addresses: [{ street: 'Shady Ln.', number: 4201 }] })

      class Either {
        static of(x) {
          return new Right(x);
        }
        constructor(x) {
          this.$value = x;
        }
      }
      class Left extends Either {
        map(f) {
          return this;
        }
        inspect() {
          return `Left(${inspect(this.$value)})`;
        }
      }
      class Right extends Either {
        map(f) {
          return Either.of(f(this.$value));
        }
        inspect() {
          return `Right(${inspect(this.$value)})`;
        }
      }
      const left = (x) => new Left(x);

      let l1 = left("rain").map(
        (str) => `It's gonna ${str}, better bring your umbrella!`
      );

      const getAge = curry((now, user) => {
        const birthDate = moment(user.birthDate, "YYYY-MM-DD");
        return birthDate.isValid()
          ? Either.of(now.diff(birthDate, "year"))
          : left("Birth date could not be parsed");
      });
      const toString = String;
      const fortune = compose(
        append("If you survive, you will be "),
        toString,
        add(1)
      );
      const zoltar = compose(map(console.log), map(fortune), getAge(moment()));
      // let z1 = zoltar({ birthDate: "2020-06-01" });
      // let g1 = getAge(moment(), { birthDate: '2005-12-12' });

      const either = curry((f, g, e) => {
        let result;

        switch (e.constructor) {
          case Left:
            result = f(e.$value);
            break;

          default:
            result = g(e.$value);
            break;
        }
        return result;
      });

      class IO {
        static of(x) {
          return new IO(() => x);
        }
        constructor(fn) {
          this.$value = fn;
        }
        map(fn) {
          return new IO(compose(fn, this.$value));
        }
        inspect() {
          return `IO(${inspect(this.$value)})`;
        }
      }
      const ioWindow = new IO(() => window);
      // let iomap = ioWindow.map(win => win.innerWidth)
      // let ret = ioWindow.map(prop('location')).map(prop('href')).map(split('/')).$value()
      // const $ = selector => new IO(() => document.querySelectorAll(selector))
      // let ret = $('#io').map(head).map(div => div.innerHTML).$value()

      const url = new IO(() => window.location.href);
      const toPairs = compose(map(split("=")), split("&"));
      const params = compose(toPairs, last, split("?"));
      const findParam = (key) => {
        // debugger
        return map(
          compose(Maybe.of, find(compose(eq(key), head)), params),
          url
        );
      };
      // let ret = findParam('name').$value()
      // console.log(ret)
      class Task {
        constructor(fork) {
          this.fork = fork;
        }

        // [util.inspect.custom]() {
        //   return "Task(?)";
        // }

        static rejected(x) {
          return new Task((reject, _) => reject(x));
        }

        // ----- Pointed (Task a)
        static of(x) {
          return new Task((_, resolve) => resolve(x));
        }

        // ----- Functor (Task a)
        map(fn) {
          return new Task((reject, resolve) =>
            this.fork(reject, compose(resolve, fn))
          );
        }

        // ----- Applicative (Task a)
        ap(f) {
          return this.chain((fn) => f.map(fn));
        }

        // ----- Monad (Task a)
        chain(fn) {
          return new Task((reject, resolve) =>
            this.fork(reject, (x) => fn(x).fork(reject, resolve))
          );
        }

        join() {
          return this.chain(identity);
        }
      }
      // let ret = IO.of("tetris").map(concat("master")).$value();
      // let ret1 = Maybe.of(1336).map(add(1)).$value;
      // let ret2 = Task.of([{ id: 2 }, { id: 3 }]).map(map(prop("id"))).fork((x) => console.log(x), reject => console.log(reject));
      // console.log(ret, ret1, ret2);
      const safeProp = curry((x, obj) => Maybe.of(obj.x));

      const firstAddressStreet = compose(
        map(map(safeProp("street"))),
        map(safeHead),
        safeProp("addresses")
      );
      let ret1 = firstAddressStreet({
        addresses: [
          { street: { name: "Mulburry", number: 8402 }, postcode: "WC2N" },
        ],
      });
      console.log(ret1);
    </script>
  </body>
</html>
