<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>ParentNode ChildNode</title>
  </head>
  <body>
    <p>
      节点对象除了继承 Node
      接口以外，还会继承其他接口。ParentNode接口表示当前节点是一个父节点，提供一些处理子节点的方法。ChildNode接口表示当前节点是一个子节点，提供一些相关方法
    </p>

    <h3>1 ParentNode 接口</h3>
    <p>
      如果当前节点是父节点，就会继承ParentNode接口。由于只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会继承ParentNode接口
    </p>

    <h5>1.1 ParentNode.children</h5>
    <p>
      children属性返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读
    </p>
    <strong
      >注意，children属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。如果没有元素类型的子节点，返回值HTMLCollection实例的length属性为0。
      另外，HTMLCollection是动态集合，会实时反映 DOM 的任何变化</strong
    >
    <script>
        // for (var i = 0; i < el.children.length; i++) {
        //   // ...
        // }
    </script>

    <h5>1.2 ParentNode.firstElementChild</h5>
    <p>
      firstElementChild属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null
    </p>
    <strong
      >上面代码中，document节点的第一个元素子节点是&lt;HTML&gt;</strong
    >
    <script>
      console.log(document.firstElementChild.nodeName) // HTML
    </script>

     <h5>1.3 ParentNode.lastElementChild</h5>
    <p>
     lastElementChild属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回null
    </p>
    <strong
      >上面代码中，document节点的最后一个元素子节点是&lt;HTML&gt;</strong
    >
    <script>
      console.log(document.lastElementChild.nodeName) // HTML
    </script>

    <section>
      <h5>1.4 ParentNode.childElementCount</h5>
    <p>
     childElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0
    </p>
    <strong
      >上面代码中，document节点的最后一个元素子节点是&lt;HTML&gt;</strong
    >
    <script>
      console.log(document.body.childElementCount) // 
    </script>
    </section>

    <section>
      <h5>1.4 ParentNode.childElementCount</h5>
    <p>
     childElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0
    </p>
    <strong
      >上面代码中，document节点的最后一个元素子节点是&lt;HTML&gt;</strong
    >
    <script>
      console.log(document.body.childElementCount) // 
    </script>
    </section>


    <section>
      <h5>1.5 ParentNode.append()，ParentNode.prepend() <section>
    <p>
     append方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。
该方法不仅可以添加元素子节点，还可以添加文本子节点。
    </p>
    <strong
      >prepend方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与append方法完全一致，也是没有返回值</strong
    >
    <script>
      var parent = document.body;

      // 添加元素子节点
      var p = document.createElement('p');
      parent.append(p);

      // 添加文本子节点
      parent.append('Hello');

      // 添加多个元素子节点
      var p1 = document.createElement('p');
      var p2 = document.createElement('p');
      parent.append(p1, p2);

      // 添加元素子节点和文本子节点
      var p = document.createElement('p');
      parent.append('Hello', p);
    </script>

    <h3>ChildNode 接口</h3>
    <p>如果一个节点有父节点，那么该节点就继承了ChildNode接口</p>

    <section>
      <h5>2.1 ChildNode.remove()</h5>
      <p>
        remove方法用于从父节点移除当前节点
      </p>
      <p></p>
      <script>
        // el.remove()
      </script>
    </section>

    <section>
      <h5>2.2 ChildNode.before()，ChildNode.after() </h5>
      <p>
        before方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。
        注意，该方法不仅可以插入元素节点，还可以插入文本节点
      </p>
      <p>after方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与before方法完全相同。</p>
      <script>
        var p = document.createElement('p');
        var p1 = document.createElement('p');

        // // 插入元素节点
        // el.before(p);

        // // 插入文本节点
        // el.before('Hello');

        // // 插入多个元素节点
        // el.before(p, p1);

        // // 插入元素节点和文本节点
        // el.before(p, 'Hello');
      </script>
    </section>

    <section>
      <h5>2.3 ChildNode.replaceWith()</h5>
      <p>
        replaceWith方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点
      </p>
      <p>上面代码中，el节点将被span节点替换</p>
      <script>
        var span = document.createElement('span');
        // el.replaceWith(span);
      </script>
    </section>
    
  </body>
</html>
