<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>javscript</title>
</head>
<body>
  <div id="d1">hello world</div>

  <div id="divA">This is <span>some</span> text</div>

  <div id="d2">hello</div><div id="d3">world</div>

  <script>
    // 1 属性
    var div = document.getElementById('d1')
    // 1.2 Node.prototype.nodeName 
    console.log(div.nodeName) // DIV

    // 1.3 Node.prototype.nodeValue
    // 只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值
    console.log(div.nodeValue) // null
    console.log(div.firstChild.nodeValue)  // hello world

    // 1.4 Node.prototype.textContent
    // textContent属性返回当前节点和它的所有后代节点的文本内容
    // textContent属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容
    console.log(document.getElementById('divA').textContent) // This is some text
    document.getElementById('divA').textContent = '<p>GoodBye!</p>'

    // 如果要读取整个文档的内容，可以使用document.documentElement.textContent。

    // 1.5 Node.prototype.baseURI

    // baseURI属性返回一个字符串，表示当前网页的绝对路径  该属性为只读 如果无法读到网页的 URL，baseURI属性返回null
    console.log(document.baseURI)

    // 1.6 Node.prototype.ownerDocument

    var d = div.ownerDocument
    console.log(d === document) // true

    // 1.7 Node.prototype.nextSibling 
    var d2 = document.getElementById('d2')
    var d3 = document.getElementById('d3')

    // 注意，该属性还包括文本节点和注释节点（<!-- comment -->）。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格
    
    console.log(d2.nextSibling === d3) // true
    console.log(d3.nextSibling)

    console.log(d3.firstChild.nextSibling) // null

    // 1.8 Node.prototype.previousSibling

    // previousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null
    console.log(d3.previousSibling === d2) // true

    // 1.9 Node.prototype.parentNode
    // parentNode属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。

    // 文档节点（document）和文档片段节点（documentfragment）的父节点都是null。另外，对于那些生成后还没插入 DOM 树的节点，父节点也是null。

    console.log(d3.parentNode)

    // Node.prototype.parentElement

    // parentElement属性返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回null。
    // 由于父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。parentElement属性相当于把后两种父节点都排除了

    let body = document.body
    let html = document.documentElement
    console.log(body.parentElement)
    console.log(html.parentElement) // null
    console.log(html.parentNode) // #document
    console.log(html.parentNode.parentNode) // null

    // 1.11 Node.prototype.firstChild，Node.prototype.lastChild

    // 如果当前节点没有子节点，则返回null
    console.log(d1.firstChild.nodeName) // #text
    console.log(d1.lastChild.nodeName) // #text

    // 1.12 Node.prototype.childNodes

    // childNodes属性返回一个类似数组的对象（NodeList集合），成员包括当前节点的所有子节点。

    console.log(d1.childNodes)

    // 文档节点（document）就有两个子节点：文档类型节点（docType）和 HTML 根元素节点。

    // 1.13 Node.prototype.isConnected

    // isConnected属性返回一个布尔值，表示当前节点是否在文档之中

    var test = document.createElement('p');
    console.log( test.isConnected) // false

    document.body.appendChild(test);
    console.log( test.isConnected) // true

    // test节点是脚本生成的节点，没有插入文档之前，isConnected属性返回false，插入之后返回true
  </script>

  <div id="mydiv">
    <form><input id="test" /></form>
  </div>
  
  <script>
    // 2 方法

    // 2.1 Node.prototype.appendChild()
    // appendChild()方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点
    let p = document.createElement('p')
    let presult = document.body.appendChild(p) 
    console.log(presult) 
    // 如果参数节点是 DOM 已经存在的节点，appendChild()方法会将其从原来的位置，移动到新位置

    let d4 = document.createDocumentFragment()
    let d5 = document.createDocumentFragment()
    d5.innerText = 'hello'
    let li = document.createElement('li')
    li.innerText = ' hello hangfeng'
    d4.appendChild(li)
    document.body.appendChild(d4) 
    document.body.appendChild(d5)  // 无显示

    // 2.2 Node.prototype.hasChildNodes()

    // hasChildNodes方法返回一个布尔值，表示当前节点是否有子节点
    console.log(d1.hasChildNodes()) // true
    // 
    function DOMComb(parent, callback) {
      if (parent.hasChildNodes()) {
        for (var node = parent.firstChild; node; node = node.nextSibling) {
          DOMComb(node, callback);
        }
      }
      callback(parent);
    }

    // 用法
    // DOMComb(document.body, console.log)

    // 2.3 Node.prototype.cloneNode()
    
    // cloneNode方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。

    //（1）克隆一个节点，会拷贝该节点的所有属性，但是会丧失addEventListener方法和on-属性（即node.onclick = fn），添加在这个节点上的事件回调函数。

    // （2）该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如Node.appendChild这样的方法添加到文档之中。

    // （3）克隆一个节点之后，DOM 有可能出现两个有相同id属性（即id="xxx"）的网页元素，这时应该修改其中一个元素的id属性。如果原节点有name属性，可能也需要修改。

    console.log(d1.cloneNode(true))  // 包含子节点
    console.log(d1.cloneNode())

    // 2.4 Node.prototype.insertBefore()

    // 这也说明insertBefore的第二个参数不能省略。// 如果insertBefore方法的第二个参数为null，则新节点将插在当前节点内部的最后位置，即变成最后一个子节点。
    let lastp = document.createElement('p')
    lastp.innerText = "lastp"
    document.body.insertBefore(lastp, null)

    // 2.5 Node.prototype.removeChild()

    // removeChild方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。
    // 
    // var element = document.getElementById('');
    // while (element.firstChild) {
    //   element.removeChild(element.firstChild);
    // }

    // 2.6 Node.prototype.replaceChild()

    // replaceChild方法接受两个参数，第一个参数newChild是用来替换的新节点，第二个参数oldChild是将要替换走的子节点。返回值是替换走的那个节点oldChild

    // 2.7 Node.prototype.contains()

    // contains方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。

      // 参数节点为当前节点。
      // 参数节点为当前节点的子节点。
      // 参数节点为当前节点的后代节点
  
    // 2.8 Node.prototype.compareDocumentPosition() 

    var div = document.getElementById('mydiv');
    var input = document.getElementById('test');

    console.log(div.compareDocumentPosition(input)) // 20
    console.log(input.compareDocumentPosition(div)) // 10

    // Node.prototype.isEqualNode()，Node.prototype.isSameNode()

    // isEqualNode方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同
      var p1 = document.createElement('p');
      var p2 = document.createElement('p');

      console.log(p1.isEqualNode(p2))

    // isSameNode方法返回一个布尔值，表示两个节点是否为同一个节点
      var p1 = document.createElement('p');
      var p2 = document.createElement('p');

      console.log(p1.isSameNode(p2)) // false
      console.log(p1.isSameNode(p1)) // true
    
    // 2.10 Node.prototype.normalize() 
    {
      var wrapper = document.createElement('div');

      wrapper.appendChild(document.createTextNode('Part 1 '));
      wrapper.appendChild(document.createTextNode('Part 2 '));

     console.log( wrapper.childNodes.length) // 2
      wrapper.normalize();
      console.log(wrapper.childNodes.length) // 1
    }

    // 2.11 Node.prototype.getRootNode()
    // getRootNode()方法返回当前节点所在文档的根节点document，与ownerDocument属性的作用相同。

    console.log(document.body.firstChild.getRootNode() === document )// true
    console.log(document.body.firstChild.getRootNode() === document.body.firstChild.ownerDocument) // true

    //该方法可用于document节点自身，这一点与document.ownerDocument不同
    console.log(document.getRootNode() )// document
    console.log(document.ownerDocument) // null
  </script>
  
</body>
</html>