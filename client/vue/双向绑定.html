<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>MVVM</title>
</head>
<body>
  <h1 id='name'>{{name}}</h1>
  <script>
    
    function SelfVue(options) {
      let self = this
      this.methods = options.methods
      this.data = options.data

      Object.keys(this.data).forEach(key => {
        self.proxyKeys(key)})

      observe(this.data)
      new Compile(options, this)
      // new Watcher(this, exp, (value) => el.innerHTML = value)
      options.mounted.call(this)
    }
    SelfVue.prototype = {

      proxyKeys(key) {
        let self = this
        Object.defineProperty(this, key, {
          enumerable: false,
          configurable: true,
          get() {
            return self.data[key]
          },
          set(value) {
            self.data[key] = value
          }
        })
      }
    }

     // observe 数据监听器
    function Observe(data) {
      this.data = data
      this.walk(data)
    }
    Observe.prototype = {
      walk(data) {
        Object.keys(data).forEach(key => {
        this.defineReactive(data, key, data[key])
      })
      },
      defineReactive(data, key, val) {
      let dep = new Dep()
      let childObj = observe(val)
      Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get() {
          if (Dep.target) { // 是否添加订阅者
            dep.addSub(Dep.target)  // 添加订阅者
          }
          return val
        },
        set(newVal) {
          if (val === newVal) {
            return
          }
          val = newVal
          console.log("属性" + key + "已经被监听,现在的值为" + newVal.toString())
          dep.notify()
        }
      }) 
    }
    }
    function observe(value, vm) {
      if (!value || typeof value !== 'object') {
        return 
      }
      return new Observe(value)
    }
    // dep
    function Dep() {
      this.subs = []
    }
    Dep.prototype = {
      addSub(sub) {
        this.subs.push(sub)
      },
      notify() {
        this.subs.forEach(sub => sub.update())
      }
    }
    Dep.target = null

    // watcher 订阅者

    function Watcher (vm, exp, cb) {
      this.cb = cb
      this.vm = vm
      this.exp = exp
      this.value = this.get()
    }
    Watcher.prototype = {
      update() {
        this.run()
      },
      run() {
        let value = this.vm.data[this.exp]
        let oldVal = this.value
        if (value !== oldVal) {
          this.value = value
          this.cb.call(this.vm, value, oldVal)
        }
      },
      get() {
        Dep.target = this
        let value = this.vm.data[this.exp]
        Dep.target = null
        return value
      }
    }

    function Compile(el, vm) {
      this.vm = vm
      this.el = document.querySelector(el)
      this.fragment = null
      this.init()
    }
    Compile.prototype = {
      init() {
        if (this.el) {
          let fragment = this.nodeToFragment(this.el)
          this.compileElement(this.fragment);
          this.el.appendChild(this.fragment);
          while(child) {
            fragment.appendChild(child)
            child = el.firstChild
          }
          return fragment
        }
      },
      nodeToFragment(el) {
        let fragment = document.createDocumentFragment()
        this.compileElement(this.fragment)
        while(child) {
          fragment.appendChild(child)
          child = el.firstChild
        }
        return fragment
      },
      compileElement(el) {
        let childNodes = el.childNodes
        let self = this;
        [].slice.call(childNodes).forEach(node => {
        let reg = /\{\{(.*)\}\}/
        let text = node.textContent

        if (self.isElementNode(node)) {
          self.compile(node)
        }
        if (self.isTextNode(node) && reg.test(text)) {
          self.compileText(node, reg.exec(text)[1])
        }
        if (node.childNodes && node.childNodes.length) {
          self.compileElement(node)
        }
      })
      },
      compile(node) {
        let nodeAttrs = node.attributes
        let self = this
        Array.prototype.forEach.call(nodeAttrs, attr => {
          let attrName = attr.name
          if (self.isDirective(attrName)) {
            var exp = attr.value;
                var dir = attrName.substring(2);
                if (self.isEventDirective(dir)) {  // 事件指令
                    self.compileEvent(node, self.vm, exp, dir);
                } else {  // v-model 指令
                    self.compileModel(node, self.vm, exp, dir);
                }
                node.removeAttribute(attrName);
          }
        })
      },
      compileEvent(node, vm, exp, dir) {
        var eventType = dir.split(':')[1];
        var cb = vm.methods && vm.methods[exp];

        if (eventType && cb) {
            node.addEventListener(eventType, cb.bind(vm), false);
        }
      },
        compileModel(node, vm, exp, dir) {
        var self = this;
        var val = this.vm[exp];
        this.modelUpdater(node, val);
        new Watcher(this.vm, exp, function (value) {
            self.modelUpdater(node, value);
        });

        node.addEventListener('input', function(e) {
            var newValue = e.target.value;
            if (val === newValue) {
                return;
            }
            self.vm[exp] = newValue;
            val = newValue;
        });
    },
      isDirective(attr) {
        return attr.indexOf('v-') == 0;
      },
      isEventDirective(attr) {
        return dir.indexOf('on:') === 0;
      },
      isElementNode(node) {
        return node.nodeType === 1
      }
    }
    function compileText (node, exp) {
      let self = this
      let initText = this.vm[exp]
      this.updateText(node, initText)
      new Watcher(this.vm, exp, value => self.updateText(node, value))
    }
    function updateText(node, value) {
      node.textContent = value ? "" : value
    }


let vm = new SelfVue({
      el: "#name",
      data: {
        name: "hello"
      }
    })

  </script>
</body>
</html>