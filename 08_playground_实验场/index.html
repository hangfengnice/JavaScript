<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .test {
        /* color: red; */
        background: linear-gradient(red, blue);
      }
    </style>
  </head>
  <body>
    <div class="test">test</div>
    <div id="app"></div>
    <!-- <script src="./render.js"></script> -->
    <script src="./reactivity.global.js"></script>

    <script>
      const queue = new Set()
      let isFlushing = false

      const p = Promise.resolve()

      function queueJob(job) {
        queue.add(job)
        if (!isFlushing) {
          isFlushing = true
          p.then(() => {
            try {
              queue.forEach((job) => job())
            } finally {
              isFlushing = false
              queue.clear()
            }
          })
        }
      }

      function shouldSetAsProps(el, key, value) {
        if (key === 'form' && el.tagName === 'INPUT') return false
        return key in el
      }

      function createRenderer(options) {
        const {
          createElement,
          setElementText,
          insert,
          patchProp,
          unmount,
          normalizeClass,
        } = options

        function patchChildren(n1, n2, container) {
          if (typeof n2.children === 'string') {
            if (Array.isArray(n1.children)) {
              n1.children.forEach((child) => unmount(child))
            }
            setElementText(container, n2.children)
          } else if (Array.isArray(n2.children)) {
            if (typeof n1.children === 'string') {
              setElementText(container, '')
              n2.children.forEach((child) => patch(null, child, container))
            } else if (Array.isArray(n1.children)) {
              const commonLength = Math.min(
                n1.children.length,
                n2.children.length,
              )
              for (let i = 0; i < commonLength; i++) {
                patch(n1.children[i], n2.children[i], container)
              }
              if (n2.children.length > n1.children.length) {
                n2.children
                  .slice(commonLength)
                  .forEach((child) => patch(null, child, container))
              } else if (n1.children.length > n2.children.length) {
                n1.children
                  .slice(commonLength)
                  .forEach((child) => unmount(child))
              }
            }
          } else {
            if (Array.isArray(n1.children)) {
              n1.children.forEach((child) => unmount(child))
            } else if (typeof n1.children === 'string') {
              setElementText(container, '')
            }
          }
        }

        function patchElement(n1, n2) {
          const el = (n2.el = n1.el)
          const oldProps = n1.props || {}
          const newProps = n2.props || {}
          for (const key in newProps) {
            if (newProps[key] !== oldProps[key]) {
              patchProp(el, key, oldProps[key], newProps[key])
            }
          }
          for (const key in oldProps) {
            if (!(key in newProps)) {
              patchProp(el, key, oldProps[key], null)
            }
          }
          patchChildren(n1, n2, el)
        }
        const Text = Symbol('Text')
        const Comment = Symbol('Comment')
        const Fragment = Symbol('Fragment')
        function mountComponent(vnode, container, anchor) {
          const componentOptions = vnode.type
          const { render, data } = componentOptions

          const state = reactive(data ? data() : {})

          const instance = {
            state,
            isMounted: false,
            subTree: null,
          }

          vnode.component = instance

          effect(
            () => {
              const subTree = render.call(state, state)
              if (!instance.isMounted) {
                patch(null, subTree, container, anchor)
                instance.isMounted = true
              } else {
                patch(instance.subTree, subTree, container, anchor)
              }
              instance.subTree = subTree
            },
            {
              scheduler: queueJob,
            },
          )
        }

        function patch(n1, n2, container, anchor = null) {
          if (n1 && n1.type !== n2.type) {
            unmount(n1)
            n1 = null
          }
          const { type } = n2
          if (typeof type === 'string') {
            if (!n1) {
              mountElement(n2, container, anchor)
            } else {
              patchElement(n1, n2)
            }
          } else if (type === Text) {
            if (!n1) {
              const el = (n2.el = document.createTextNode(n2.children))
              insert(el, container, anchor)
            } else {
              const el = (n2.el = n1.el)
              if (n2.children !== n1.children) {
                el.nodeValue = n2.children
              }
            }
          } else if (type === Fragment) {
            if (!n1) {
              n2.children.forEach((child) =>
                patch(null, child, container, anchor),
              )
            } else {
              patchChildren(n1, n2, container)
            }
          } else if (typeof type === 'object') {
            if (!n1) {
              mountComponent(n2, container, anchor)
            } else {
              patchComponent(n1, n2, container, anchor)
            }
          } else if (!n1) {
            mountElement(n2, container, anchor)
          } else {
            // updateElement(n1, n2, container)
          }
        }
        function mountElement(vnode, container, anchor = null) {
          const el = (vnode.el = createElement(vnode.type))

          if (vnode.props) {
            for (const key in vnode.props) {
              patchProp(el, key, null, vnode.props[key])
            }
          }

          if (typeof vnode.children === 'string') {
            setElementText(el, vnode.children)
          } else if (Array.isArray(vnode.children)) {
            vnode.children.forEach((child) => {
              patch(null, child, el, anchor)
            })
          }
          insert(el, container, anchor)
        }
        function render(vnode, container) {
          if (vnode) {
            patch(container._vnode || null, vnode, container, null)
          } else {
            if (container._vnode) {
              unmount(container._vnode)
            }
          }
          container._vnode = vnode
        }

        return {
          render,
        }
      }

      const renderer = createRenderer({
        createElement(tag) {
          return document.createElement(tag)
        },
        setElementText(el, text) {
          el.textContent = text
        },
        insert(el, parent, anchor = null) {
          parent.insertBefore(el, anchor)
        },
        patchProp(el, key, prevValue, nextValue) {
          if (/^on/.test(key)) {
            let invokers = el._vei || (el._vei = {})
            let invoker = invokers[key]
            const eventName = key.slice(2).toLowerCase()
            if (nextValue) {
              if (!invoker) {
                invoker = invokers[key] = (e) => {
                  console.log(
                    e.timeStamp,
                    typeof e.timeStamp,
                    invoker.attached,
                    e.timeStamp < invoker.attached,
                    'time',
                  )
                  if (e.timeStamp < invoker.attached) {
                    return
                  }
                  if (Array.isArray(invoker.value)) {
                    invoker.value.forEach((fn) => fn(e))
                  } else {
                    invoker.value(e)
                  }
                }
              }
              invoker.value = nextValue
              invoker.attached = performance.now()
              el.addEventListener(eventName, invoker)
            } else if (invoker) {
              el.removeEventListener(eventName, invoker)
              invokers[key] = undefined
            }
          } else if (key === 'class') {
            el.className = nextValue || ''
          } else if (shouldSetAsProps(el, key, nextValue)) {
            const type = typeof el[key]
            if (type === 'boolean' && nextValue === '') {
              el[key] = true
            } else {
              el[key] = nextValue
            }
          } else if (key === 'class') {
            el.className = nextValue || ''
          } else if (shouldSetAsProps(el, key, nextValue)) {
            const type = typeof el[key]
            if (type === 'boolean' && nextValue === '') {
              el[key] = true
            } else {
              el[key] = nextValue
            }
          } else {
            el.setAttribute(key, nextValue)
          }
        },
        unmount(vnode) {
          if (vnode.type === Fragment) {
            vnode.children.forEach((child) => unmount(child))
            return
          }
          const el = vnode.el
          const parent = el.parentNode
          if (parent) {
            parent.removeChild(el)
          }
        },
        normalizeClass(value) {
          if (typeof value === 'string') {
            return value
          } else if (Array.isArray(value)) {
            return value.map(normalizeClass).filter(Boolean).join(' ')
          } else if (typeof value === 'object') {
            return Object.keys(value)
              .filter((key) => value[key])
              .join(' ')
          }
        },
      }).render

      const myComponent = {
        name: 'my-component',
        data() {
          return {
            foo: 'foo',
          }
        },
        render() {
          return {
            type: 'h1',
            children: `${this.foo} zhangsan`,
          }
        },
      }

      const { reactive, effect, ref } = VueReactivity

      const CompVnode = {
        type: myComponent,
      }

      renderer(CompVnode, document.getElementById('app'))

      // const bol = ref(false)

      // effect(() => {
      //   const vnode = {
      //     type: 'h1',
      //     props: bol.value
      //       ? {
      //           id: 'hello',
      //           onClick() {
      //             console.log('father click')
      //           },
      //         }
      //       : {},
      //     children: [
      //       {
      //         type: 'span',
      //         children: 'text',
      //         props: {
      //           onClick() {
      //             bol.value = !bol.value
      //           },
      //         },
      //       },
      //     ],
      //   }
      //   renderer(vnode, document.getElementById('app'))
      // })
    </script>

    <script></script>
  </body>
</html>
