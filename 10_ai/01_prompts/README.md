与codex沟通指南

1. 先提出1个小的需求, 要求小步优化
2. 每次优化后, 先测试, 保证功能正确, 自己理解了代码 是否满足需求, 再提出下一个小的需求
3. 反复迭代, 直到满足需求
4. 过程中, 遇到好的实现, 让记录下来, 以便下次复用
5. 过程中, 遇到不好的实现, 也要记录下来, 以便下次避免
6. 一定要避免一次做过多的需求
  6.1 过多的需求会codex反应变慢
  6.2 过多的需求会导致沟通困难, 难以明确需求, 难以评估进度
7. 一定要保持沟通畅


针对你的这套指南，我从 Mac 用户的高效工作流和 AI 交互深度两个维度，给出几点进阶建议：

1. 补充“上下文管理” (Context Management)
AI 的记忆（上下文窗口）是有限的。当迭代次数过多时，早期的约定可能会被遗忘。

建议： 增加一个“状态同步”步骤。每 5-8 次小步优化后，让 AI 总结当前的“代码全貌”或“已实现的逻辑清单”。

操作： “请总结目前我们已经完成的功能模块和核心变量定义，确认为下一步优化做准备。”

2. 细化“记录”的动作 (Documentation)
你提到的第 4 点（记录好实现）和第 5 点（记录坏实现）非常关键。在 Mac 上，你可以利用 Raycast Snippets 或 Obsidian/Notion 建立一个 AI-Interaction-Log。

建议： 明确记录“Prompt 模式”。有些需求 AI 做得好，往往是因为你的某个提问方式（Prompt）触发了它的正确逻辑。

操作： 记录“成功的指令（Winning Prompt）”和“失败的指令（Failing Prompt）”。

3. 引入“防御性提问” (Defensive Prompting)
在第 2 步（测试与理解）中，AI 有时会显得“过度自信”。

建议： 在 AI 给出代码后，反问一句：“这段代码在什么边界条件下可能会失效？”或者“这个实现是否符合 [具体编程语言] 的最佳实践（Best Practice）？”

价值： 这能强迫 AI 进行自我审计，发现你可能忽视的潜在 Bug。

4. 建立“版本检查点” (Checkpoints)
既然你使用 Mac，利用好 Git 或 Finder 的复制功能。

建议： 在每次重大优化成功后，进行一次 git commit 或手动备份当前代码文件。

理由： 即使 AI 沟通顺畅，有时也会在第 N 步优化时意外破坏第 N-2 步的功能。有了检查点，你可以迅速回滚。

5. 优化“需求分级” (Requirement Tiering)
针对第 6 点（避免过多需求），你可以建立一个“待办池”。

建议： 维护一个 Pending-Features.md。每次只从池子里拿一个最小颗粒度的任务给 AI，其他的保持在视线之外，避免干扰。